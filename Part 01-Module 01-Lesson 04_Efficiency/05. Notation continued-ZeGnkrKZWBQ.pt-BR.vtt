WEBVTT
Kind: captions
Language: pt-BR

00:00:00.235 --> 00:00:03.268
Vou repetir que aqueles
eram apenas os conceitos básicos.

00:00:03.302 --> 00:00:06.736
Agora nós vamos estudar
as várias complicações possíveis.

00:00:06.769 --> 00:00:10.736
Primeiramente, no exemplo anterior,
temos que pensar no laço de for.

00:00:10.769 --> 00:00:13.702
O laço de for
conta como alguma coisa?

00:00:13.736 --> 00:00:18.135
Para que o laço funcione,
você precisa computar todas as vezes

00:00:18.168 --> 00:00:20.534
para chegar
ao próximo caractere na string.

00:00:21.001 --> 00:00:24.769
Já que isto precisa acontecer uma vez
a cada caractere de entrada,

00:00:24.802 --> 00:00:28.028
podemos somar um
ao valor antes de n

00:00:28.061 --> 00:00:31.298
e a expressão será 3n + 2.

00:00:31.335 --> 00:00:35.635
Na verdade, é muito difícil prever
quantas computações

00:00:35.669 --> 00:00:38.435
este pseudocódigo
vai utilizar.

00:00:38.468 --> 00:00:41.602
Por exemplo, uma linguagem
de nível inferior como a C

00:00:41.635 --> 00:00:45.569
daria mais erros durante o processo
e precisaria de mais linhas no código

00:00:45.602 --> 00:00:48.535
mas teria menos processos
em andamento em segundo plano.

00:00:48.569 --> 00:00:52.402
Talvez a versão Python
tenha o mesmo número de linhas de código,

00:00:52.435 --> 00:00:57.502
mas teria mais processos em segundo plano
pois é uma linguagem de nível alto.

00:00:57.535 --> 00:01:00.402
Por exemplo,
vamos observar esta linha.

00:01:00.435 --> 00:01:03.435
Esta linha pode utilizar
várias computações

00:01:03.469 --> 00:01:07.134
dependendo da estrutura dos dados
que a cifra está usando.

00:01:07.736 --> 00:01:09.736
Se tivermos armazenado
os dados em uma lista,

00:01:09.769 --> 00:01:12.739
precisamos conferir cada caractere
em comparação aos nossos caracteres

00:01:12.773 --> 00:01:14.503
para solucionar o código.

00:01:14.535 --> 00:01:16.810
O resultado poderia ser
de 26 computações

00:01:16.844 --> 00:01:20.047
para cada caractere
na string de entrada.

00:01:20.068 --> 00:01:25.901
O cálculo de eficiência
provavelmente será assim.

00:01:25.935 --> 00:01:29.901
Vamos voltar aos exemplos
de strings de entrada.

00:01:29.935 --> 00:01:33.427
Se começarmos com uma string
de entrada de 10 caracteres,

00:01:33.460 --> 00:01:36.769
teremos 292 computações.

00:01:36.802 --> 00:01:40.068
Se começarmos com 1 milhão
de caracteres na string de entrada,

00:01:40.102 --> 00:01:43.802
teremos que passar
por 29 milhões de etapas.

00:01:43.836 --> 00:01:46.373
Devido a escolha
de estrutura de dados,

00:01:46.406 --> 00:01:49.309
faremos mais computações
do que o necessário

00:01:49.343 --> 00:01:51.512
se escolhermos
sendo mais inteligentes.

00:01:51.535 --> 00:01:53.313
Nós vamos estudar
um pouco mais

00:01:53.347 --> 00:01:56.183
sobre a eficiência de tipos diferentes
de estruturas de dados.

00:01:56.202 --> 00:01:59.119
Espero que agora
você perceba a importância

00:01:59.152 --> 00:02:02.056
de pensar na eficiência
antes de criar o código.

