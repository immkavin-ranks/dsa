WEBVTT
Kind: captions
Language: ja-JP

00:00:00.360 --> 00:00:03.400
先ほども言いましたが
これらは単なる基本に過ぎず

00:00:03.400 --> 00:00:06.859
解決しなければならない
複雑な問題がまだたくさん残っています

00:00:06.860 --> 00:00:10.879
まず、前の例では for ループについて
考慮しなければなりません

00:00:10.880 --> 00:00:13.820
for は何かをカウントして
いるのでしょうか

00:00:13.820 --> 00:00:16.100
ループを機能させるには

00:00:16.100 --> 00:00:20.000
毎回計算を行って文字列に含まれる次の文字を
取得する必要があります

00:00:21.140 --> 00:00:26.250
文字を 1 つ入力するたびに
計算の必要が生じるため

00:00:26.250 --> 00:00:31.720
n の前の値に 1 を足し
3n + 2 とします

00:00:31.720 --> 00:00:35.700
この擬似コードで必要な
計算回数を推定することは

00:00:35.700 --> 00:00:38.770
非常に困難だとわかりました

00:00:38.770 --> 00:00:41.940
たとえば
プログラミング言語の基本である C では

00:00:41.940 --> 00:00:45.949
プロセスをより細かく分割するので
コードの行が増えてしまいますが

00:00:45.950 --> 00:00:48.660
バックグラウンドタスクは
それほど多くありません

00:00:48.660 --> 00:00:53.169
Python でもおそらく
コードの行は同程度になると思いますが

00:00:53.170 --> 00:00:56.710
より高度な言語なので
バックグラウンドタスクの量は

00:00:56.710 --> 00:00:57.960
増えるでしょう

00:00:57.960 --> 00:01:00.815
たとえば、この行を見てみます

00:01:00.815 --> 00:01:03.515
この行はデータ構造によって
計算回数が異なってきます

00:01:03.515 --> 00:01:06.605
ここでは暗号が
使われています

00:01:07.875 --> 00:01:09.855
そこでデータをリストに格納し

00:01:09.855 --> 00:01:13.612
各文字を現在の文字と照合して
コードの解読を試みます

00:01:14.662 --> 00:01:18.992
この入力文字列における各文字の
チェック回数は最大 26 回となります

00:01:20.202 --> 00:01:26.202
そのため、効率の演算は
このようになりそうです

00:01:26.202 --> 00:01:30.262
先ほどの入力文字列の例に戻って
考えてみましょう

00:01:30.262 --> 00:01:33.232
10 文字で構成される
入力文字列の場合

00:01:33.232 --> 00:01:37.230
計算回数は 292 回になり

00:01:37.230 --> 00:01:40.210
100 万文字であれば

00:01:40.210 --> 00:01:44.500
2900 万回になります

00:01:44.500 --> 00:01:47.450
このようなデータ構造を使用しているため
計算回数が多くなっていますが

00:01:47.450 --> 00:01:51.840
よりスマートなデータ構造を採用すれば
これほど多くはなりません

00:01:51.840 --> 00:01:54.880
他のデータ構造における
効率の違いについては

00:01:54.880 --> 00:01:56.690
後ほど説明しますが

00:01:56.690 --> 00:02:00.420
効率を考慮した上でコードを
記述することの重要性については

00:02:00.420 --> 00:02:01.300
おわかりいただけたと思います

